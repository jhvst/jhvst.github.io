@article{doctoral_thesis_mogers,
  author = {Mogers, Naums},
  doi = {10.7488/era/3587},
  title = {Guided rewriting and constraint satisfaction for parallel GPU code generation},
  url = {http://dx.doi.org/10.7488/era/3587},
  year = {2023},
}

@article{ContinuationPaGibbon2021,
  author = {Gibbons, Jeremy},
  doi = {10.22152/programming-journal.org/2022/6/7},
  issue = {2},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  month = {11},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  title = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  url = {http://dx.doi.org/10.22152/programming-journal.org/2022/6/7},
  volume = {6},
  year = {2021},
}

@inbook{AplicativeProgGibbon2017,
  author = {Gibbons, Jeremy},
  doi = {10.1007/978-3-662-54434-1\_21},
  isbn = {['9783662544334', '9783662544341']},
  journal = {Programming Languages and Systems},
  month = {3},
  pages = {556--583},
  publisher = {Springer Berlin Heidelberg},
  title = {APLicative Programming with Naperian~Functors},
  url = {http://dx.doi.org/10.1007/978-3-662-54434-1\_21},
  year = {2017},
}

@article{SsaIsFunctionAppel1998,
  author = {Appel, Andrew W.},
  doi = {10.1145/278283.278285},
  issue = {4},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {4},
  pages = {17--20},
  publisher = {Association for Computing Machinery (ACM)},
  title = {SSA is functional programming},
  url = {http://dx.doi.org/10.1145/278283.278285},
  volume = {33},
  year = {1998},
}

@article{augeas,
  author = {Lutterkort, David},
  title = {AUGEAS - a configuration API},
  url = {https://www.kernel.org/doc/ols/2008/ols2008v2-pages-47-56.pdf},
}

@article{act2023par,
  author = {Wilson, Paul and Zanasi, Fabio},
  title = {Data-Parallel Algorithms for String Diagrams},
  url = {https://act2023.github.io/papers/paper32.pdf},
}

@article{TowardsHaskellEpstei2012,
  abstract = {<jats:p>We present Cloud Haskell, a domain-specific language for developing programs for a distributed computing environment. Implemented as a shallow embedding in Haskell, it provides a message-passing communication model, inspired by Erlang, without introducing incompatibility with Haskell's established shared-memory concurrency. A key contribution is a method for serializing function closures for transmission across the network. Cloud Haskell has been implemented; we present example code and some preliminary performance measurements.</jats:p>},
  author = {Epstein, Jeff and Black, Andrew P. and Peyton-Jones, Simon},
  doi = {10.1145/2096148.2034690},
  issue = {12},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {1},
  pages = {118--129},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Towards Haskell in the cloud},
  url = {http://dx.doi.org/10.1145/2096148.2034690},
  volume = {46},
  year = {2012},
}

@inbook{TypeSystemsFoMcbrid2022,
  author = {McBride, Conor and Nordvall-Forsberg, Fredrik},
  doi = {10.1142/9789811242380\_0020},
  journal = {Series on Advances in Mathematics for Applied Sciences},
  month = {2},
  pages = {331--345},
  publisher = {WORLD SCIENTIFIC},
  title = {Type systems for programs respecting dimensions},
  url = {http://dx.doi.org/10.1142/9789811242380\_0020},
  year = {2022},
}

@article{IntroductionToShiver2019,
  abstract = {Remora is a higher-order, rank-polymorphic array-processing programming language, in the same general class of languages as APL and J. It is intended for writing programs to be executed on parallel hardware.   We provide an example-driven introduction to the language, and its general computational model, originally developed by Iverson for APL. We begin with Dynamic Remora, a variant of the language with a dynamic type system (as in Scheme or Lisp), to introduce the fundamental computational mechanisms of the language, then shift to Explicitly Typed Remora, a variant of the language with a static, dependent type system that permits the shape of the arrays being computed to be captured at compile time.   This article can be considered an introduction to the general topic of the rank-polymorphic array-processing computational model, above and beyond the specific details of the Remora language.   We do not address the details of type inference in Remora, that is, the assignment of explicit types to programs written without such annotations; this is ongoing research.},
  archiveprefix = {arXiv},
  author = {Shivers, Olin and Slepak, Justin and Manolios, Panagiotis},
  eprint = {1912.13451v2},
  file = {1912.13451v2.pdf},
  month = {Dec},
  primaryclass = {cs.PL},
  title = {Introduction to Rank-polymorphic Programming in Remora (Draft)},
  url = {http://arxiv.org/abs/1912.13451v2},
  year = {2019},
}@article{doctoral_thesis_mogers,
  author = {Mogers, Naums},
  doi = {10.7488/era/3587},
  title = {Guided rewriting and constraint satisfaction for parallel GPU code generation},
  url = {http://dx.doi.org/10.7488/era/3587},
  year = {2023},
}

@article{ContinuationPaGibbon2021,
  author = {Gibbons, Jeremy},
  doi = {10.22152/programming-journal.org/2022/6/7},
  issue = {2},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  month = {11},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  title = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  url = {http://dx.doi.org/10.22152/programming-journal.org/2022/6/7},
  volume = {6},
  year = {2021},
}

@inbook{AplicativeProgGibbon2017,
  author = {Gibbons, Jeremy},
  doi = {10.1007/978-3-662-54434-1\_21},
  isbn = {['9783662544334', '9783662544341']},
  journal = {Programming Languages and Systems},
  month = {3},
  pages = {556--583},
  publisher = {Springer Berlin Heidelberg},
  title = {APLicative Programming with Naperian~Functors},
  url = {http://dx.doi.org/10.1007/978-3-662-54434-1\_21},
  year = {2017},
}

@article{SsaIsFunctionAppel1998,
  author = {Appel, Andrew W.},
  doi = {10.1145/278283.278285},
  issue = {4},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {4},
  pages = {17--20},
  publisher = {Association for Computing Machinery (ACM)},
  title = {SSA is functional programming},
  url = {http://dx.doi.org/10.1145/278283.278285},
  volume = {33},
  year = {1998},
}

@article{augeas,
  author = {Lutterkort, David},
  title = {AUGEAS - a configuration API},
  url = {https://www.kernel.org/doc/ols/2008/ols2008v2-pages-47-56.pdf},
}

@article{act2023par,
  author = {Wilson, Paul and Zanasi, Fabio},
  title = {Data-Parallel Algorithms for String Diagrams},
  url = {https://act2023.github.io/papers/paper32.pdf},
}

@article{TowardsHaskellEpstei2012,
  abstract = {<jats:p>We present Cloud Haskell, a domain-specific language for developing programs for a distributed computing environment. Implemented as a shallow embedding in Haskell, it provides a message-passing communication model, inspired by Erlang, without introducing incompatibility with Haskell's established shared-memory concurrency. A key contribution is a method for serializing function closures for transmission across the network. Cloud Haskell has been implemented; we present example code and some preliminary performance measurements.</jats:p>},
  author = {Epstein, Jeff and Black, Andrew P. and Peyton-Jones, Simon},
  doi = {10.1145/2096148.2034690},
  issue = {12},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {1},
  pages = {118--129},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Towards Haskell in the cloud},
  url = {http://dx.doi.org/10.1145/2096148.2034690},
  volume = {46},
  year = {2012},
}

@inbook{TypeSystemsFoMcbrid2022,
  author = {McBride, Conor and Nordvall-Forsberg, Fredrik},
  doi = {10.1142/9789811242380\_0020},
  journal = {Series on Advances in Mathematics for Applied Sciences},
  month = {2},
  pages = {331--345},
  publisher = {WORLD SCIENTIFIC},
  title = {Type systems for programs respecting dimensions},
  url = {http://dx.doi.org/10.1142/9789811242380\_0020},
  year = {2022},
}

@article{IntroductionToShiver2019,
  abstract = {Remora is a higher-order, rank-polymorphic array-processing programming language, in the same general class of languages as APL and J. It is intended for writing programs to be executed on parallel hardware.   We provide an example-driven introduction to the language, and its general computational model, originally developed by Iverson for APL. We begin with Dynamic Remora, a variant of the language with a dynamic type system (as in Scheme or Lisp), to introduce the fundamental computational mechanisms of the language, then shift to Explicitly Typed Remora, a variant of the language with a static, dependent type system that permits the shape of the arrays being computed to be captured at compile time.   This article can be considered an introduction to the general topic of the rank-polymorphic array-processing computational model, above and beyond the specific details of the Remora language.   We do not address the details of type inference in Remora, that is, the assignment of explicit types to programs written without such annotations; this is ongoing research.},
  archiveprefix = {arXiv},
  author = {Shivers, Olin and Slepak, Justin and Manolios, Panagiotis},
  eprint = {1912.13451v2},
  file = {1912.13451v2.pdf},
  month = {Dec},
  primaryclass = {cs.PL},
  title = {Introduction to Rank-polymorphic Programming in Remora (Draft)},
  url = {http://arxiv.org/abs/1912.13451v2},
  year = {2019},
}@article{doctoral_thesis_mogers,
  author = {Mogers, Naums},
  doi = {10.7488/era/3587},
  title = {Guided rewriting and constraint satisfaction for parallel GPU code generation},
  url = {http://dx.doi.org/10.7488/era/3587},
  year = {2023},
}

@article{ContinuationPaGibbon2021,
  author = {Gibbons, Jeremy},
  doi = {10.22152/programming-journal.org/2022/6/7},
  issue = {2},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  month = {11},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  title = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  url = {http://dx.doi.org/10.22152/programming-journal.org/2022/6/7},
  volume = {6},
  year = {2021},
}

@article{GettingToThePaszke2021,
  abstract = {We present a novel programming language design that attempts to combine the clarity and safety of high-level functional languages with the efficiency and parallelism of low-level numerical languages. We treat arrays as eagerly-memoized functions on typed index sets, allowing abstract function manipulations, such as currying, to work on arrays. In contrast to composing primitive bulk-array operations, we argue for an explicit nested indexing style that mirrors application of functions to arguments. We also introduce a fine-grained typed effects system which affords concise and automatically-parallelized in-place updates. Specifically, an associative accumulation effect allows reverse-mode automatic differentiation of in-place updates in a way that preserves parallelism. Empirically, we benchmark against the Futhark array programming language, and demonstrate that aggressive inlining and type-driven compilation allows array programs to be written in an expressive, "pointful" style with little performance penalty.},
  archiveprefix = {arXiv},
  author = {Paszke, Adam and Johnson, Daniel and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
  eprint = {2104.05372v1},
  file = {2104.05372v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Getting to the Point. Index Sets and Parallelism-Preserving Autodiff for   Pointful Array Programming},
  url = {http://arxiv.org/abs/2104.05372v1},
  year = {2021},
}

@inbook{AplicativeProgGibbon2017,
  author = {Gibbons, Jeremy},
  doi = {10.1007/978-3-662-54434-1\_21},
  isbn = {['9783662544334', '9783662544341']},
  journal = {Programming Languages and Systems},
  month = {3},
  pages = {556--583},
  publisher = {Springer Berlin Heidelberg},
  title = {APLicative Programming with Naperian~Functors},
  url = {http://dx.doi.org/10.1007/978-3-662-54434-1\_21},
  year = {2017},
}

@article{SsaIsFunctionAppel1998,
  author = {Appel, Andrew W.},
  doi = {10.1145/278283.278285},
  issue = {4},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {4},
  pages = {17--20},
  publisher = {Association for Computing Machinery (ACM)},
  title = {SSA is functional programming},
  url = {http://dx.doi.org/10.1145/278283.278285},
  volume = {33},
  year = {1998},
}

@article{augeas,
  author = {Lutterkort, David},
  title = {AUGEAS - a configuration API},
  url = {https://www.kernel.org/doc/ols/2008/ols2008v2-pages-47-56.pdf},
}

@article{IntroductionToShiver2019,
  abstract = {Remora is a higher-order, rank-polymorphic array-processing programming language, in the same general class of languages as APL and J. It is intended for writing programs to be executed on parallel hardware.   We provide an example-driven introduction to the language, and its general computational model, originally developed by Iverson for APL. We begin with Dynamic Remora, a variant of the language with a dynamic type system (as in Scheme or Lisp), to introduce the fundamental computational mechanisms of the language, then shift to Explicitly Typed Remora, a variant of the language with a static, dependent type system that permits the shape of the arrays being computed to be captured at compile time.   This article can be considered an introduction to the general topic of the rank-polymorphic array-processing computational model, above and beyond the specific details of the Remora language.   We do not address the details of type inference in Remora, that is, the assignment of explicit types to programs written without such annotations; this is ongoing research.},
  archiveprefix = {arXiv},
  author = {Shivers, Olin and Slepak, Justin and Manolios, Panagiotis},
  eprint = {1912.13451v2},
  file = {1912.13451v2.pdf},
  month = {Dec},
  primaryclass = {cs.PL},
  title = {Introduction to Rank-polymorphic Programming in Remora (Draft)},
  url = {http://arxiv.org/abs/1912.13451v2},
  year = {2019},
}

@article{act2023par,
  author = {Wilson, Paul and Zanasi, Fabio},
  title = {Data-Parallel Algorithms for String Diagrams},
  url = {https://act2023.github.io/papers/paper32.pdf},
}

@article{TowardsHaskellEpstei2012,
  abstract = {<jats:p>We present Cloud Haskell, a domain-specific language for developing programs for a distributed computing environment. Implemented as a shallow embedding in Haskell, it provides a message-passing communication model, inspired by Erlang, without introducing incompatibility with Haskell's established shared-memory concurrency. A key contribution is a method for serializing function closures for transmission across the network. Cloud Haskell has been implemented; we present example code and some preliminary performance measurements.</jats:p>},
  author = {Epstein, Jeff and Black, Andrew P. and Peyton-Jones, Simon},
  doi = {10.1145/2096148.2034690},
  issue = {12},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {1},
  pages = {118--129},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Towards Haskell in the cloud},
  url = {http://dx.doi.org/10.1145/2096148.2034690},
  volume = {46},
  year = {2012},
}

@inbook{TypeSystemsFoMcbrid2022,
  author = {McBride, Conor and Nordvall-Forsberg, Fredrik},
  doi = {10.1142/9789811242380\_0020},
  journal = {Series on Advances in Mathematics for Applied Sciences},
  month = {2},
  pages = {331--345},
  publisher = {WORLD SCIENTIFIC},
  title = {Type systems for programs respecting dimensions},
  url = {http://dx.doi.org/10.1142/9789811242380\_0020},
  year = {2022},
}@article{doctoral_thesis_mogers,
  author = {Mogers, Naums},
  doi = {10.7488/era/3587},
  title = {Guided rewriting and constraint satisfaction for parallel GPU code generation},
  url = {http://dx.doi.org/10.7488/era/3587},
  year = {2023},
}

@article{ContinuationPaGibbon2021,
  author = {Gibbons, Jeremy},
  doi = {10.22152/programming-journal.org/2022/6/7},
  issue = {2},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  month = {11},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  title = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  url = {http://dx.doi.org/10.22152/programming-journal.org/2022/6/7},
  volume = {6},
  year = {2021},
}

@article{GettingToThePaszke2021,
  abstract = {We present a novel programming language design that attempts to combine the clarity and safety of high-level functional languages with the efficiency and parallelism of low-level numerical languages. We treat arrays as eagerly-memoized functions on typed index sets, allowing abstract function manipulations, such as currying, to work on arrays. In contrast to composing primitive bulk-array operations, we argue for an explicit nested indexing style that mirrors application of functions to arguments. We also introduce a fine-grained typed effects system which affords concise and automatically-parallelized in-place updates. Specifically, an associative accumulation effect allows reverse-mode automatic differentiation of in-place updates in a way that preserves parallelism. Empirically, we benchmark against the Futhark array programming language, and demonstrate that aggressive inlining and type-driven compilation allows array programs to be written in an expressive, "pointful" style with little performance penalty.},
  archiveprefix = {arXiv},
  author = {Paszke, Adam and Johnson, Daniel and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
  eprint = {2104.05372v1},
  file = {2104.05372v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Getting to the Point. Index Sets and Parallelism-Preserving Autodiff for   Pointful Array Programming},
  url = {http://arxiv.org/abs/2104.05372v1},
  year = {2021},
}

@inbook{AplicativeProgGibbon2017,
  author = {Gibbons, Jeremy},
  doi = {10.1007/978-3-662-54434-1\_21},
  isbn = {['9783662544334', '9783662544341']},
  journal = {Programming Languages and Systems},
  month = {3},
  pages = {556--583},
  publisher = {Springer Berlin Heidelberg},
  title = {APLicative Programming with Naperian~Functors},
  url = {http://dx.doi.org/10.1007/978-3-662-54434-1\_21},
  year = {2017},
}

@article{SsaIsFunctionAppel1998,
  author = {Appel, Andrew W.},
  doi = {10.1145/278283.278285},
  issue = {4},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {4},
  pages = {17--20},
  publisher = {Association for Computing Machinery (ACM)},
  title = {SSA is functional programming},
  url = {http://dx.doi.org/10.1145/278283.278285},
  volume = {33},
  year = {1998},
}

@article{augeas,
  author = {Lutterkort, David},
  title = {AUGEAS - a configuration API},
  url = {https://www.kernel.org/doc/ols/2008/ols2008v2-pages-47-56.pdf},
}

@article{IntroductionToShiver2019,
  abstract = {Remora is a higher-order, rank-polymorphic array-processing programming language, in the same general class of languages as APL and J. It is intended for writing programs to be executed on parallel hardware.   We provide an example-driven introduction to the language, and its general computational model, originally developed by Iverson for APL. We begin with Dynamic Remora, a variant of the language with a dynamic type system (as in Scheme or Lisp), to introduce the fundamental computational mechanisms of the language, then shift to Explicitly Typed Remora, a variant of the language with a static, dependent type system that permits the shape of the arrays being computed to be captured at compile time.   This article can be considered an introduction to the general topic of the rank-polymorphic array-processing computational model, above and beyond the specific details of the Remora language.   We do not address the details of type inference in Remora, that is, the assignment of explicit types to programs written without such annotations; this is ongoing research.},
  archiveprefix = {arXiv},
  author = {Shivers, Olin and Slepak, Justin and Manolios, Panagiotis},
  eprint = {1912.13451v2},
  file = {1912.13451v2.pdf},
  month = {Dec},
  primaryclass = {cs.PL},
  title = {Introduction to Rank-polymorphic Programming in Remora (Draft)},
  url = {http://arxiv.org/abs/1912.13451v2},
  year = {2019},
}

@article{act2023par,
  author = {Wilson, Paul and Zanasi, Fabio},
  title = {Data-Parallel Algorithms for String Diagrams},
  url = {https://act2023.github.io/papers/paper32.pdf},
}

@article{TowardsHaskellEpstei2012,
  abstract = {<jats:p>We present Cloud Haskell, a domain-specific language for developing programs for a distributed computing environment. Implemented as a shallow embedding in Haskell, it provides a message-passing communication model, inspired by Erlang, without introducing incompatibility with Haskell's established shared-memory concurrency. A key contribution is a method for serializing function closures for transmission across the network. Cloud Haskell has been implemented; we present example code and some preliminary performance measurements.</jats:p>},
  author = {Epstein, Jeff and Black, Andrew P. and Peyton-Jones, Simon},
  doi = {10.1145/2096148.2034690},
  issue = {12},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {1},
  pages = {118--129},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Towards Haskell in the cloud},
  url = {http://dx.doi.org/10.1145/2096148.2034690},
  volume = {46},
  year = {2012},
}

@inbook{TypeSystemsFoMcbrid2022,
  author = {McBride, Conor and Nordvall-Forsberg, Fredrik},
  doi = {10.1142/9789811242380\_0020},
  journal = {Series on Advances in Mathematics for Applied Sciences},
  month = {2},
  pages = {331--345},
  publisher = {WORLD SCIENTIFIC},
  title = {Type systems for programs respecting dimensions},
  url = {http://dx.doi.org/10.1142/9789811242380\_0020},
  year = {2022},
}

@article{Idris2QuantiBrady2021,
  abstract = {Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. As yet, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this paper, we introduce Idris 2, and describe how QTT has influenced its design. We give examples of the benefits of QTT in practice including: expressing which data is erased at run time, at the type level; and, resource tracking in the type system leading to type-safe concurrent programming with session types.},
  archiveprefix = {arXiv},
  author = {Brady, Edwin},
  eprint = {2104.00480v1},
  file = {2104.00480v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Idris 2: Quantitative Type Theory in Practice},
  url = {http://arxiv.org/abs/2104.00480v1},
  year = {2021},
}

@article{QuantitativePrOrchar2019,
  abstract = {<jats:p>In programming, some data acts as a resource (e.g., file handles, channels) subject to usage constraints. This poses a challenge to software correctness as most languages are agnostic to constraints on data. The approach of linear types provides a partial remedy, delineating data into resources to be used but never copied or discarded, and unconstrained values. Bounded Linear Logic provides a more fine-grained approach, quantifying non-linear use via an indexed-family of modalities. Recent work on coeffect types generalises this idea to graded comonads, providing type systems which can capture various program properties. Here, we propose the umbrella notion of graded modal types, encompassing coeffect types and dual notions of type-based effect reasoning via graded monads. In combination with linear and indexed types, we show that graded modal types provide an expressive type theory for quantitative program reasoning, advancing the reach of type systems to capture and verify a broader set of program properties. We demonstrate this approach via a type system embodied in a fully-fledged functional language called Granule, exploring various examples.</jats:p>},
  author = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
  doi = {10.1145/3341714},
  issue = {ICFP},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  month = {7},
  pages = {1--30},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Quantitative program reasoning with graded modal types},
  url = {http://dx.doi.org/10.1145/3341714},
  volume = {3},
  year = {2019},
}

@inproceedings{HowToTakeTheMarsha2022,
  address = {Dagstuhl, Germany},
  annote = {Keywords: linear types, regular types, algebra of programming, derivatives},
  author = {Marshall, Daniel and Orchard, Dominic},
  booktitle = {36th European Conference on Object-Oriented Programming (ECOOP 2022)},
  doi = {10.4230/LIPIcs.ECOOP.2022.5},
  editor = {Ali, Karim and Vitek, Jan},
  isbn = {978-3-95977-225-9},
  issn = {1868-8969},
  pages = {5:1--5:27},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f\lbrace{}\textbackslash{}"u\rbrace{}r Informatik},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {How to Take the Inverse of a Type},
  url = {https://drops.dagstuhl.de/opus/volltexte/2022/16233},
  volume = {222},
  year = {2022},
}@article{doctoral_thesis_mogers,
  author = {Mogers, Naums},
  doi = {10.7488/era/3587},
  title = {Guided rewriting and constraint satisfaction for parallel GPU code generation},
  url = {http://dx.doi.org/10.7488/era/3587},
  year = {2023},
}

@article{ContinuationPaGibbon2021,
  author = {Gibbons, Jeremy},
  doi = {10.22152/programming-journal.org/2022/6/7},
  issue = {2},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  month = {11},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  title = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  url = {http://dx.doi.org/10.22152/programming-journal.org/2022/6/7},
  volume = {6},
  year = {2021},
}

@article{GettingToThePaszke2021,
  abstract = {We present a novel programming language design that attempts to combine the clarity and safety of high-level functional languages with the efficiency and parallelism of low-level numerical languages. We treat arrays as eagerly-memoized functions on typed index sets, allowing abstract function manipulations, such as currying, to work on arrays. In contrast to composing primitive bulk-array operations, we argue for an explicit nested indexing style that mirrors application of functions to arguments. We also introduce a fine-grained typed effects system which affords concise and automatically-parallelized in-place updates. Specifically, an associative accumulation effect allows reverse-mode automatic differentiation of in-place updates in a way that preserves parallelism. Empirically, we benchmark against the Futhark array programming language, and demonstrate that aggressive inlining and type-driven compilation allows array programs to be written in an expressive, "pointful" style with little performance penalty.},
  archiveprefix = {arXiv},
  author = {Paszke, Adam and Johnson, Daniel and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
  eprint = {2104.05372v1},
  file = {2104.05372v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Getting to the Point. Index Sets and Parallelism-Preserving Autodiff for   Pointful Array Programming},
  url = {http://arxiv.org/abs/2104.05372v1},
  year = {2021},
}

@inbook{AplicativeProgGibbon2017,
  author = {Gibbons, Jeremy},
  doi = {10.1007/978-3-662-54434-1\_21},
  isbn = {['9783662544334', '9783662544341']},
  journal = {Programming Languages and Systems},
  month = {3},
  pages = {556--583},
  publisher = {Springer Berlin Heidelberg},
  title = {APLicative Programming with Naperian~Functors},
  url = {http://dx.doi.org/10.1007/978-3-662-54434-1\_21},
  year = {2017},
}

@article{SsaIsFunctionAppel1998,
  author = {Appel, Andrew W.},
  doi = {10.1145/278283.278285},
  issue = {4},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {4},
  pages = {17--20},
  publisher = {Association for Computing Machinery (ACM)},
  title = {SSA is functional programming},
  url = {http://dx.doi.org/10.1145/278283.278285},
  volume = {33},
  year = {1998},
}

@article{augeas,
  author = {Lutterkort, David},
  title = {AUGEAS - a configuration API},
  url = {https://www.kernel.org/doc/ols/2008/ols2008v2-pages-47-56.pdf},
}

@article{IntroductionToShiver2019,
  abstract = {Remora is a higher-order, rank-polymorphic array-processing programming language, in the same general class of languages as APL and J. It is intended for writing programs to be executed on parallel hardware.   We provide an example-driven introduction to the language, and its general computational model, originally developed by Iverson for APL. We begin with Dynamic Remora, a variant of the language with a dynamic type system (as in Scheme or Lisp), to introduce the fundamental computational mechanisms of the language, then shift to Explicitly Typed Remora, a variant of the language with a static, dependent type system that permits the shape of the arrays being computed to be captured at compile time.   This article can be considered an introduction to the general topic of the rank-polymorphic array-processing computational model, above and beyond the specific details of the Remora language.   We do not address the details of type inference in Remora, that is, the assignment of explicit types to programs written without such annotations; this is ongoing research.},
  archiveprefix = {arXiv},
  author = {Shivers, Olin and Slepak, Justin and Manolios, Panagiotis},
  eprint = {1912.13451v2},
  file = {1912.13451v2.pdf},
  month = {Dec},
  primaryclass = {cs.PL},
  title = {Introduction to Rank-polymorphic Programming in Remora (Draft)},
  url = {http://arxiv.org/abs/1912.13451v2},
  year = {2019},
}

@article{act2023par,
  author = {Wilson, Paul and Zanasi, Fabio},
  title = {Data-Parallel Algorithms for String Diagrams},
  url = {https://act2023.github.io/papers/paper32.pdf},
}

@article{TowardsHaskellEpstei2012,
  abstract = {<jats:p>We present Cloud Haskell, a domain-specific language for developing programs for a distributed computing environment. Implemented as a shallow embedding in Haskell, it provides a message-passing communication model, inspired by Erlang, without introducing incompatibility with Haskell's established shared-memory concurrency. A key contribution is a method for serializing function closures for transmission across the network. Cloud Haskell has been implemented; we present example code and some preliminary performance measurements.</jats:p>},
  author = {Epstein, Jeff and Black, Andrew P. and Peyton-Jones, Simon},
  doi = {10.1145/2096148.2034690},
  issue = {12},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {1},
  pages = {118--129},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Towards Haskell in the cloud},
  url = {http://dx.doi.org/10.1145/2096148.2034690},
  volume = {46},
  year = {2012},
}

@inbook{TypeSystemsFoMcbrid2022,
  author = {McBride, Conor and Nordvall-Forsberg, Fredrik},
  doi = {10.1142/9789811242380\_0020},
  journal = {Series on Advances in Mathematics for Applied Sciences},
  month = {2},
  pages = {331--345},
  publisher = {WORLD SCIENTIFIC},
  title = {Type systems for programs respecting dimensions},
  url = {http://dx.doi.org/10.1142/9789811242380\_0020},
  year = {2022},
}

@article{Idris2QuantiBrady2021,
  abstract = {Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. As yet, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this paper, we introduce Idris 2, and describe how QTT has influenced its design. We give examples of the benefits of QTT in practice including: expressing which data is erased at run time, at the type level; and, resource tracking in the type system leading to type-safe concurrent programming with session types.},
  archiveprefix = {arXiv},
  author = {Brady, Edwin},
  eprint = {2104.00480v1},
  file = {2104.00480v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Idris 2: Quantitative Type Theory in Practice},
  url = {http://arxiv.org/abs/2104.00480v1},
  year = {2021},
}

@article{QuantitativePrOrchar2019,
  abstract = {<jats:p>In programming, some data acts as a resource (e.g., file handles, channels) subject to usage constraints. This poses a challenge to software correctness as most languages are agnostic to constraints on data. The approach of linear types provides a partial remedy, delineating data into resources to be used but never copied or discarded, and unconstrained values. Bounded Linear Logic provides a more fine-grained approach, quantifying non-linear use via an indexed-family of modalities. Recent work on coeffect types generalises this idea to graded comonads, providing type systems which can capture various program properties. Here, we propose the umbrella notion of graded modal types, encompassing coeffect types and dual notions of type-based effect reasoning via graded monads. In combination with linear and indexed types, we show that graded modal types provide an expressive type theory for quantitative program reasoning, advancing the reach of type systems to capture and verify a broader set of program properties. We demonstrate this approach via a type system embodied in a fully-fledged functional language called Granule, exploring various examples.</jats:p>},
  author = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
  doi = {10.1145/3341714},
  issue = {ICFP},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  month = {7},
  pages = {1--30},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Quantitative program reasoning with graded modal types},
  url = {http://dx.doi.org/10.1145/3341714},
  volume = {3},
  year = {2019},
}

@inproceedings{HowToTakeTheMarsha2022,
  address = {Dagstuhl, Germany},
  annote = {Keywords: linear types, regular types, algebra of programming, derivatives},
  author = {Marshall, Daniel and Orchard, Dominic},
  booktitle = {36th European Conference on Object-Oriented Programming (ECOOP 2022)},
  doi = {10.4230/LIPIcs.ECOOP.2022.5},
  editor = {Ali, Karim and Vitek, Jan},
  isbn = {978-3-95977-225-9},
  issn = {1868-8969},
  pages = {5:1--5:27},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f\lbrace{}\textbackslash{}"u\rbrace{}r Informatik},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {How to Take the Inverse of a Type},
  url = {https://drops.dagstuhl.de/opus/volltexte/2022/16233},
  volume = {222},
  year = {2022},
}

@inproceedings{FutharkPurelyHenrik2017,
  author = {Henriksen, Troels and Serup, Niels G. W. and Elsman, Martin and Henglein, Fritz and Oancea, Cosmin E.},
  booktitle = {PLDI '17: ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/3062341.3062354},
  journal = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  month = {6},
  publisher = {ACM},
  title = {Futhark: purely functional GPU-programming with nested parallelism and in-place array updates},
  url = {http://dx.doi.org/10.1145/3062341.3062354},
  venue = {Barcelona Spain},
  year = {2017},
}

@article{ADataParallelAaron2019,
  author = {Aaron Hsu},
  title = {A data parallel compiler hosted on the GPU},
  year = {2019},
}

@inproceedings{UNetCnnInApHsuA2023,
  author = {Hsu, Aaron W. and Serr\~{a}o, Rodrigo Gir\~{a}o},
  booktitle = {ARRAY '23: 9th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  doi = {10.1145/3589246.3595371},
  journal = {Proceedings of the 9th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {U-Net CNN in APL: Exploring Zero-Framework, Zero-Library Machine Learning},
  url = {http://dx.doi.org/10.1145/3589246.3595371},
  venue = {Orlando FL USA},
  year = {2023},
}

@inproceedings{AplOnGpusAHenrik2016,
  author = {Henriksen, Troels and Dybdal, Martin and Urms, Henrik and Kiehn, Anna Sofie and Gavin, Daniel and Abelskov, Hjalte and Elsman, Martin and Oancea, Cosmin},
  booktitle = {ICFP'16: ACM SIGPLAN International Conference on Functional Programming},
  doi = {10.1145/2975991.2975997},
  journal = {Proceedings of the 5th International Workshop on Functional High-Performance Computing},
  month = {9},
  publisher = {ACM},
  title = {APL on GPUs: a TAIL from the past, scribbled in Futhark},
  url = {http://dx.doi.org/10.1145/2975991.2975997},
  venue = {Nara Japan},
  year = {2016},
}

@inproceedings{CompilationOnVoette2022,
  author = {Voetter, Robin F. and Huijben, Marcel and Rietveld, Kristian F. D.},
  booktitle = {CF '22: 19th ACM International Conference on Computing Frontiers},
  doi = {10.1145/3528416.3530249},
  journal = {Proceedings of the 19th ACM International Conference on Computing Frontiers},
  month = {5},
  publisher = {ACM},
  title = {Compilation on the GPU?},
  url = {http://dx.doi.org/10.1145/3528416.3530249},
  venue = {Turin Italy},
  year = {2022},
}

@inproceedings{CompilingAplTBudde2015,
  author = {Budde, Michael and Dybdal, Martin and Elsman, Martin},
  booktitle = {PLDI '15: ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/2774959.2774966},
  journal = {Proceedings of the 2nd ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {Compiling APL to accelerate through a typed array intermediate language},
  url = {http://dx.doi.org/10.1145/2774959.2774966},
  venue = {Portland OR USA},
  year = {2015},
}

@inproceedings{UnleashingGpusHaavis2022,
  author = {Haavisto, Juuso and Cholez, Thibault and Riekki, Jukka},
  booktitle = {NOMS 2022-2022 IEEE/IFIP Network Operations and Management Symposium},
  doi = {10.1109/noms54207.2022.9789822},
  journal = {NOMS 2022-2022 IEEE/IFIP Network Operations and Management Symposium},
  month = {4},
  publisher = {IEEE},
  title = {Unleashing GPUs for Network Function Virtualization: an open architecture based on Vulkan and Kubernetes},
  url = {http://dx.doi.org/10.1109/noms54207.2022.9789822},
  venue = {Budapest, Hungary},
  year = {2022},
}

@inproceedings{AcceleratingApGrelck1998,
  author = {Grelck, Clemens and Scholz, Sven-Bodo},
  booktitle = {APL99: 1999 Conference on APL},
  doi = {10.1145/312627.312719},
  journal = {Proceedings of the conference on APL \textbackslash{}textquotesingle 99 : On track to the 21st century: On track to the 21st century},
  month = {12},
  publisher = {ACM},
  title = {Accelerating APL programs with SAC},
  url = {http://dx.doi.org/10.1145/312627.312719},
  venue = {Scranton Pennsylvania USA},
  year = {1998},
}

@inproceedings{TeilATypeSaRink2019,
  author = {Rink, Norman A. and Castrillon, Jeronimo},
  booktitle = {PLDI '19: 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/3315454.3329959},
  journal = {Proceedings of the 6th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {TeIL: a type-safe imperative tensor intermediate language},
  url = {http://dx.doi.org/10.1145/3315454.3329959},
  venue = {Phoenix AZ USA},
  year = {2019},
}

@article{ApexTheAplPRobert1997,
  author = {Robert Bernecky},
  title = {APEX, the APL parallel executor},
  year = {1997},
}

@article{AplSince1978HuiR2020,
  abstract = {<jats:p>
            <jats:italic>The Evolution of APL</jats:italic>
            , the HOPL I paper by Falkoff and Iverson on APL, recounted the fundamental design principles which shaped the implementation of the APL language in 1966, and the early uses and other influences which shaped its first decade of enhancements.
          </jats:p>
          <jats:p>In the 40 years that have elapsed since HOPL I, several dozen APL implementations have come and gone. In the first decade or two, interpreters were typically born and buried along with the hardware or operating system that they were created for. More recently, the use of C as an implementation language provided APL interpreters with greater longevity and portability.</jats:p>
          <jats:p>
            APL started its life on IBM mainframes which were time-shared by multiple users. As the demand for computing resources grew and costs dropped, APL first moved
            <jats:italic>in-house</jats:italic>
            to mainframes, then to
            <jats:italic>mini</jats:italic>
            - and
            <jats:italic>micro</jats:italic>
            -computers. Today, APL runs on PCs and tablets, Apples and Raspberry Pis, smartphones and watches.
          </jats:p>
          <jats:p>The operating systems, and the software application platforms that APL runs on, have evolved beyond recognition. Tools like database systems have taken over many of the tasks that were initially implemented in APL or provided by the APL system, and new capabilities like parallel hardware have also changed the focus of design and implementation efforts through the years.</jats:p>
          <jats:p>The first wave of significant language enhancements occurred shortly after HOPL I, resulting in so-called second-generation APL systems. The most important feature of the second generation is the addition of general arrays\textemdash{}in which any item of an array can be another array\textemdash{}and a number of new functions and operators aligned with, if not always motivated by, the new data structures.</jats:p>
          <jats:p>The majority of implementations followed IBM's path with APL2 \textquotedblleft{}floating\textquotedblright{} arrays; others aligned themselves with SHARP APL and \textquotedblleft{}grounded\textquotedblright{} arrays. While the APL2 style of APL interpreters came to dominate the mainstream of the APL community, two new cousins of APL descended from the SHARP APL family tree: J (created by Iverson and Hui) and k (created by Arthur Whitney).</jats:p>
          <jats:p>We attempt to follow a reasonable number of threads through the last 40 years, to identify the most important factors that have shaped the evolution of APL. We will discuss the details of what we believe are the most significant language features that made it through the occasionally unnatural selection imposed by the loss of habitats that disappeared with hardware, software platforms, and business models.</jats:p>
          <jats:p>The history of APL now spans six decades. It is still the case, as Falkoff and Iverson remarked at the end of the HOPL I paper, that:</jats:p>
          <jats:p>Although this is not the place to discuss the future, it should be remarked that the evolution of APL is far from finished.</jats:p>},
  author = {Hui, Roger K. W. and Kromberg, Morten J.},
  doi = {10.1145/3386319},
  issue = {HOPL},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  month = {6},
  pages = {1--108},
  publisher = {Association for Computing Machinery (ACM)},
  title = {APL since 1978},
  url = {http://dx.doi.org/10.1145/3386319},
  volume = {4},
  year = {2020},
}@article{doctoral_thesis_mogers,
  author = {Mogers, Naums},
  doi = {10.7488/era/3587},
  title = {Guided rewriting and constraint satisfaction for parallel GPU code generation},
  url = {http://dx.doi.org/10.7488/era/3587},
  year = {2023},
}

@article{ContinuationPaGibbon2021,
  author = {Gibbons, Jeremy},
  doi = {10.22152/programming-journal.org/2022/6/7},
  issue = {2},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  month = {11},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  title = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  url = {http://dx.doi.org/10.22152/programming-journal.org/2022/6/7},
  volume = {6},
  year = {2021},
}

@article{GettingToThePaszke2021,
  abstract = {We present a novel programming language design that attempts to combine the clarity and safety of high-level functional languages with the efficiency and parallelism of low-level numerical languages. We treat arrays as eagerly-memoized functions on typed index sets, allowing abstract function manipulations, such as currying, to work on arrays. In contrast to composing primitive bulk-array operations, we argue for an explicit nested indexing style that mirrors application of functions to arguments. We also introduce a fine-grained typed effects system which affords concise and automatically-parallelized in-place updates. Specifically, an associative accumulation effect allows reverse-mode automatic differentiation of in-place updates in a way that preserves parallelism. Empirically, we benchmark against the Futhark array programming language, and demonstrate that aggressive inlining and type-driven compilation allows array programs to be written in an expressive, "pointful" style with little performance penalty.},
  archiveprefix = {arXiv},
  author = {Paszke, Adam and Johnson, Daniel and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
  eprint = {2104.05372v1},
  file = {2104.05372v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Getting to the Point. Index Sets and Parallelism-Preserving Autodiff for   Pointful Array Programming},
  url = {http://arxiv.org/abs/2104.05372v1},
  year = {2021},
}

@inbook{AplicativeProgGibbon2017,
  author = {Gibbons, Jeremy},
  doi = {10.1007/978-3-662-54434-1\_21},
  isbn = {['9783662544334', '9783662544341']},
  journal = {Programming Languages and Systems},
  month = {3},
  pages = {556--583},
  publisher = {Springer Berlin Heidelberg},
  title = {APLicative Programming with Naperian~Functors},
  url = {http://dx.doi.org/10.1007/978-3-662-54434-1\_21},
  year = {2017},
}

@article{SsaIsFunctionAppel1998,
  author = {Appel, Andrew W.},
  doi = {10.1145/278283.278285},
  issue = {4},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {4},
  pages = {17--20},
  publisher = {Association for Computing Machinery (ACM)},
  title = {SSA is functional programming},
  url = {http://dx.doi.org/10.1145/278283.278285},
  volume = {33},
  year = {1998},
}

@article{augeas,
  author = {Lutterkort, David},
  title = {AUGEAS - a configuration API},
  url = {https://www.kernel.org/doc/ols/2008/ols2008v2-pages-47-56.pdf},
}

@article{IntroductionToShiver2019,
  abstract = {Remora is a higher-order, rank-polymorphic array-processing programming language, in the same general class of languages as APL and J. It is intended for writing programs to be executed on parallel hardware.   We provide an example-driven introduction to the language, and its general computational model, originally developed by Iverson for APL. We begin with Dynamic Remora, a variant of the language with a dynamic type system (as in Scheme or Lisp), to introduce the fundamental computational mechanisms of the language, then shift to Explicitly Typed Remora, a variant of the language with a static, dependent type system that permits the shape of the arrays being computed to be captured at compile time.   This article can be considered an introduction to the general topic of the rank-polymorphic array-processing computational model, above and beyond the specific details of the Remora language.   We do not address the details of type inference in Remora, that is, the assignment of explicit types to programs written without such annotations; this is ongoing research.},
  archiveprefix = {arXiv},
  author = {Shivers, Olin and Slepak, Justin and Manolios, Panagiotis},
  eprint = {1912.13451v2},
  file = {1912.13451v2.pdf},
  month = {Dec},
  primaryclass = {cs.PL},
  title = {Introduction to Rank-polymorphic Programming in Remora (Draft)},
  url = {http://arxiv.org/abs/1912.13451v2},
  year = {2019},
}

@article{act2023par,
  author = {Wilson, Paul and Zanasi, Fabio},
  title = {Data-Parallel Algorithms for String Diagrams},
  url = {https://act2023.github.io/papers/paper32.pdf},
}

@article{TowardsHaskellEpstei2012,
  abstract = {<jats:p>We present Cloud Haskell, a domain-specific language for developing programs for a distributed computing environment. Implemented as a shallow embedding in Haskell, it provides a message-passing communication model, inspired by Erlang, without introducing incompatibility with Haskell's established shared-memory concurrency. A key contribution is a method for serializing function closures for transmission across the network. Cloud Haskell has been implemented; we present example code and some preliminary performance measurements.</jats:p>},
  author = {Epstein, Jeff and Black, Andrew P. and Peyton-Jones, Simon},
  doi = {10.1145/2096148.2034690},
  issue = {12},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {1},
  pages = {118--129},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Towards Haskell in the cloud},
  url = {http://dx.doi.org/10.1145/2096148.2034690},
  volume = {46},
  year = {2012},
}

@inbook{TypeSystemsFoMcbrid2022,
  author = {McBride, Conor and Nordvall-Forsberg, Fredrik},
  doi = {10.1142/9789811242380\_0020},
  journal = {Series on Advances in Mathematics for Applied Sciences},
  month = {2},
  pages = {331--345},
  publisher = {WORLD SCIENTIFIC},
  title = {Type systems for programs respecting dimensions},
  url = {http://dx.doi.org/10.1142/9789811242380\_0020},
  year = {2022},
}

@article{Idris2QuantiBrady2021,
  abstract = {Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. As yet, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this paper, we introduce Idris 2, and describe how QTT has influenced its design. We give examples of the benefits of QTT in practice including: expressing which data is erased at run time, at the type level; and, resource tracking in the type system leading to type-safe concurrent programming with session types.},
  archiveprefix = {arXiv},
  author = {Brady, Edwin},
  eprint = {2104.00480v1},
  file = {2104.00480v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Idris 2: Quantitative Type Theory in Practice},
  url = {http://arxiv.org/abs/2104.00480v1},
  year = {2021},
}

@article{QuantitativePrOrchar2019,
  abstract = {<jats:p>In programming, some data acts as a resource (e.g., file handles, channels) subject to usage constraints. This poses a challenge to software correctness as most languages are agnostic to constraints on data. The approach of linear types provides a partial remedy, delineating data into resources to be used but never copied or discarded, and unconstrained values. Bounded Linear Logic provides a more fine-grained approach, quantifying non-linear use via an indexed-family of modalities. Recent work on coeffect types generalises this idea to graded comonads, providing type systems which can capture various program properties. Here, we propose the umbrella notion of graded modal types, encompassing coeffect types and dual notions of type-based effect reasoning via graded monads. In combination with linear and indexed types, we show that graded modal types provide an expressive type theory for quantitative program reasoning, advancing the reach of type systems to capture and verify a broader set of program properties. We demonstrate this approach via a type system embodied in a fully-fledged functional language called Granule, exploring various examples.</jats:p>},
  author = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
  doi = {10.1145/3341714},
  issue = {ICFP},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  month = {7},
  pages = {1--30},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Quantitative program reasoning with graded modal types},
  url = {http://dx.doi.org/10.1145/3341714},
  volume = {3},
  year = {2019},
}

@inproceedings{HowToTakeTheMarsha2022,
  address = {Dagstuhl, Germany},
  annote = {Keywords: linear types, regular types, algebra of programming, derivatives},
  author = {Marshall, Daniel and Orchard, Dominic},
  booktitle = {36th European Conference on Object-Oriented Programming (ECOOP 2022)},
  doi = {10.4230/LIPIcs.ECOOP.2022.5},
  editor = {Ali, Karim and Vitek, Jan},
  isbn = {978-3-95977-225-9},
  issn = {1868-8969},
  pages = {5:1--5:27},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f\lbrace{}\textbackslash{}"u\rbrace{}r Informatik},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {How to Take the Inverse of a Type},
  url = {https://drops.dagstuhl.de/opus/volltexte/2022/16233},
  volume = {222},
  year = {2022},
}

@inproceedings{FutharkPurelyHenrik2017,
  author = {Henriksen, Troels and Serup, Niels G. W. and Elsman, Martin and Henglein, Fritz and Oancea, Cosmin E.},
  booktitle = {PLDI '17: ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/3062341.3062354},
  journal = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  month = {6},
  publisher = {ACM},
  title = {Futhark: purely functional GPU-programming with nested parallelism and in-place array updates},
  url = {http://dx.doi.org/10.1145/3062341.3062354},
  venue = {Barcelona Spain},
  year = {2017},
}

@article{ADataParallelAaron2019,
  author = {Aaron Hsu},
  title = {A data parallel compiler hosted on the GPU},
  year = {2019},
}

@inproceedings{UNetCnnInApHsuA2023,
  author = {Hsu, Aaron W. and Serr\~{a}o, Rodrigo Gir\~{a}o},
  booktitle = {ARRAY '23: 9th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  doi = {10.1145/3589246.3595371},
  journal = {Proceedings of the 9th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {U-Net CNN in APL: Exploring Zero-Framework, Zero-Library Machine Learning},
  url = {http://dx.doi.org/10.1145/3589246.3595371},
  venue = {Orlando FL USA},
  year = {2023},
}

@inproceedings{AplOnGpusAHenrik2016,
  author = {Henriksen, Troels and Dybdal, Martin and Urms, Henrik and Kiehn, Anna Sofie and Gavin, Daniel and Abelskov, Hjalte and Elsman, Martin and Oancea, Cosmin},
  booktitle = {ICFP'16: ACM SIGPLAN International Conference on Functional Programming},
  doi = {10.1145/2975991.2975997},
  journal = {Proceedings of the 5th International Workshop on Functional High-Performance Computing},
  month = {9},
  publisher = {ACM},
  title = {APL on GPUs: a TAIL from the past, scribbled in Futhark},
  url = {http://dx.doi.org/10.1145/2975991.2975997},
  venue = {Nara Japan},
  year = {2016},
}

@inproceedings{CompilationOnVoette2022,
  author = {Voetter, Robin F. and Huijben, Marcel and Rietveld, Kristian F. D.},
  booktitle = {CF '22: 19th ACM International Conference on Computing Frontiers},
  doi = {10.1145/3528416.3530249},
  journal = {Proceedings of the 19th ACM International Conference on Computing Frontiers},
  month = {5},
  publisher = {ACM},
  title = {Compilation on the GPU?},
  url = {http://dx.doi.org/10.1145/3528416.3530249},
  venue = {Turin Italy},
  year = {2022},
}

@inproceedings{CompilingAplTBudde2015,
  author = {Budde, Michael and Dybdal, Martin and Elsman, Martin},
  booktitle = {PLDI '15: ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/2774959.2774966},
  journal = {Proceedings of the 2nd ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {Compiling APL to accelerate through a typed array intermediate language},
  url = {http://dx.doi.org/10.1145/2774959.2774966},
  venue = {Portland OR USA},
  year = {2015},
}

@inproceedings{UnleashingGpusHaavis2022,
  author = {Haavisto, Juuso and Cholez, Thibault and Riekki, Jukka},
  booktitle = {NOMS 2022-2022 IEEE/IFIP Network Operations and Management Symposium},
  doi = {10.1109/noms54207.2022.9789822},
  journal = {NOMS 2022-2022 IEEE/IFIP Network Operations and Management Symposium},
  month = {4},
  publisher = {IEEE},
  title = {Unleashing GPUs for Network Function Virtualization: an open architecture based on Vulkan and Kubernetes},
  url = {http://dx.doi.org/10.1109/noms54207.2022.9789822},
  venue = {Budapest, Hungary},
  year = {2022},
}

@inproceedings{AcceleratingApGrelck1998,
  author = {Grelck, Clemens and Scholz, Sven-Bodo},
  booktitle = {APL99: 1999 Conference on APL},
  doi = {10.1145/312627.312719},
  journal = {Proceedings of the conference on APL \textbackslash{}textquotesingle 99 : On track to the 21st century: On track to the 21st century},
  month = {12},
  publisher = {ACM},
  title = {Accelerating APL programs with SAC},
  url = {http://dx.doi.org/10.1145/312627.312719},
  venue = {Scranton Pennsylvania USA},
  year = {1998},
}

@inproceedings{TeilATypeSaRink2019,
  author = {Rink, Norman A. and Castrillon, Jeronimo},
  booktitle = {PLDI '19: 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/3315454.3329959},
  journal = {Proceedings of the 6th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {TeIL: a type-safe imperative tensor intermediate language},
  url = {http://dx.doi.org/10.1145/3315454.3329959},
  venue = {Phoenix AZ USA},
  year = {2019},
}

@article{ApexTheAplPRobert1997,
  author = {Robert Bernecky},
  title = {APEX, the APL parallel executor},
  year = {1997},
}

@article{AplSince1978HuiR2020,
  abstract = {<jats:p>
            <jats:italic>The Evolution of APL</jats:italic>
            , the HOPL I paper by Falkoff and Iverson on APL, recounted the fundamental design principles which shaped the implementation of the APL language in 1966, and the early uses and other influences which shaped its first decade of enhancements.
          </jats:p>
          <jats:p>In the 40 years that have elapsed since HOPL I, several dozen APL implementations have come and gone. In the first decade or two, interpreters were typically born and buried along with the hardware or operating system that they were created for. More recently, the use of C as an implementation language provided APL interpreters with greater longevity and portability.</jats:p>
          <jats:p>
            APL started its life on IBM mainframes which were time-shared by multiple users. As the demand for computing resources grew and costs dropped, APL first moved
            <jats:italic>in-house</jats:italic>
            to mainframes, then to
            <jats:italic>mini</jats:italic>
            - and
            <jats:italic>micro</jats:italic>
            -computers. Today, APL runs on PCs and tablets, Apples and Raspberry Pis, smartphones and watches.
          </jats:p>
          <jats:p>The operating systems, and the software application platforms that APL runs on, have evolved beyond recognition. Tools like database systems have taken over many of the tasks that were initially implemented in APL or provided by the APL system, and new capabilities like parallel hardware have also changed the focus of design and implementation efforts through the years.</jats:p>
          <jats:p>The first wave of significant language enhancements occurred shortly after HOPL I, resulting in so-called second-generation APL systems. The most important feature of the second generation is the addition of general arrays\textemdash{}in which any item of an array can be another array\textemdash{}and a number of new functions and operators aligned with, if not always motivated by, the new data structures.</jats:p>
          <jats:p>The majority of implementations followed IBM's path with APL2 \textquotedblleft{}floating\textquotedblright{} arrays; others aligned themselves with SHARP APL and \textquotedblleft{}grounded\textquotedblright{} arrays. While the APL2 style of APL interpreters came to dominate the mainstream of the APL community, two new cousins of APL descended from the SHARP APL family tree: J (created by Iverson and Hui) and k (created by Arthur Whitney).</jats:p>
          <jats:p>We attempt to follow a reasonable number of threads through the last 40 years, to identify the most important factors that have shaped the evolution of APL. We will discuss the details of what we believe are the most significant language features that made it through the occasionally unnatural selection imposed by the loss of habitats that disappeared with hardware, software platforms, and business models.</jats:p>
          <jats:p>The history of APL now spans six decades. It is still the case, as Falkoff and Iverson remarked at the end of the HOPL I paper, that:</jats:p>
          <jats:p>Although this is not the place to discuss the future, it should be remarked that the evolution of APL is far from finished.</jats:p>},
  author = {Hui, Roger K. W. and Kromberg, Morten J.},
  doi = {10.1145/3386319},
  issue = {HOPL},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  month = {6},
  pages = {1--108},
  publisher = {Association for Computing Machinery (ACM)},
  title = {APL since 1978},
  url = {http://dx.doi.org/10.1145/3386319},
  volume = {4},
  year = {2020},
}@article{doctoral_thesis_mogers,
  author = {Mogers, Naums},
  doi = {10.7488/era/3587},
  title = {Guided rewriting and constraint satisfaction for parallel GPU code generation},
  url = {http://dx.doi.org/10.7488/era/3587},
  year = {2023},
}

@article{ContinuationPaGibbon2021,
  author = {Gibbons, Jeremy},
  doi = {10.22152/programming-journal.org/2022/6/7},
  issue = {2},
  journal = {The Art, Science, and Engineering of Programming},
  language = {en},
  month = {11},
  publisher = {Aspect-Oriented Software Association (AOSA)},
  title = {Continuation-Passing Style, Defunctionalization, Accumulations, and Associativity},
  url = {http://dx.doi.org/10.22152/programming-journal.org/2022/6/7},
  volume = {6},
  year = {2021},
}

@article{GettingToThePaszke2021,
  abstract = {We present a novel programming language design that attempts to combine the clarity and safety of high-level functional languages with the efficiency and parallelism of low-level numerical languages. We treat arrays as eagerly-memoized functions on typed index sets, allowing abstract function manipulations, such as currying, to work on arrays. In contrast to composing primitive bulk-array operations, we argue for an explicit nested indexing style that mirrors application of functions to arguments. We also introduce a fine-grained typed effects system which affords concise and automatically-parallelized in-place updates. Specifically, an associative accumulation effect allows reverse-mode automatic differentiation of in-place updates in a way that preserves parallelism. Empirically, we benchmark against the Futhark array programming language, and demonstrate that aggressive inlining and type-driven compilation allows array programs to be written in an expressive, "pointful" style with little performance penalty.},
  archiveprefix = {arXiv},
  author = {Paszke, Adam and Johnson, Daniel and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
  eprint = {2104.05372v1},
  file = {2104.05372v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Getting to the Point. Index Sets and Parallelism-Preserving Autodiff for   Pointful Array Programming},
  url = {http://arxiv.org/abs/2104.05372v1},
  year = {2021},
}

@inbook{AplicativeProgGibbon2017,
  author = {Gibbons, Jeremy},
  doi = {10.1007/978-3-662-54434-1\_21},
  isbn = {['9783662544334', '9783662544341']},
  journal = {Programming Languages and Systems},
  month = {3},
  pages = {556--583},
  publisher = {Springer Berlin Heidelberg},
  title = {APLicative Programming with Naperian~Functors},
  url = {http://dx.doi.org/10.1007/978-3-662-54434-1\_21},
  year = {2017},
}

@article{SsaIsFunctionAppel1998,
  author = {Appel, Andrew W.},
  doi = {10.1145/278283.278285},
  issue = {4},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {4},
  pages = {17--20},
  publisher = {Association for Computing Machinery (ACM)},
  title = {SSA is functional programming},
  url = {http://dx.doi.org/10.1145/278283.278285},
  volume = {33},
  year = {1998},
}

@article{augeas,
  author = {Lutterkort, David},
  title = {AUGEAS - a configuration API},
  url = {https://www.kernel.org/doc/ols/2008/ols2008v2-pages-47-56.pdf},
}

@article{IntroductionToShiver2019,
  abstract = {Remora is a higher-order, rank-polymorphic array-processing programming language, in the same general class of languages as APL and J. It is intended for writing programs to be executed on parallel hardware.   We provide an example-driven introduction to the language, and its general computational model, originally developed by Iverson for APL. We begin with Dynamic Remora, a variant of the language with a dynamic type system (as in Scheme or Lisp), to introduce the fundamental computational mechanisms of the language, then shift to Explicitly Typed Remora, a variant of the language with a static, dependent type system that permits the shape of the arrays being computed to be captured at compile time.   This article can be considered an introduction to the general topic of the rank-polymorphic array-processing computational model, above and beyond the specific details of the Remora language.   We do not address the details of type inference in Remora, that is, the assignment of explicit types to programs written without such annotations; this is ongoing research.},
  archiveprefix = {arXiv},
  author = {Shivers, Olin and Slepak, Justin and Manolios, Panagiotis},
  eprint = {1912.13451v2},
  file = {1912.13451v2.pdf},
  month = {Dec},
  primaryclass = {cs.PL},
  title = {Introduction to Rank-polymorphic Programming in Remora (Draft)},
  url = {http://arxiv.org/abs/1912.13451v2},
  year = {2019},
}

@article{act2023par,
  author = {Wilson, Paul and Zanasi, Fabio},
  title = {Data-Parallel Algorithms for String Diagrams},
  url = {https://act2023.github.io/papers/paper32.pdf},
}

@article{TowardsHaskellEpstei2012,
  abstract = {<jats:p>We present Cloud Haskell, a domain-specific language for developing programs for a distributed computing environment. Implemented as a shallow embedding in Haskell, it provides a message-passing communication model, inspired by Erlang, without introducing incompatibility with Haskell's established shared-memory concurrency. A key contribution is a method for serializing function closures for transmission across the network. Cloud Haskell has been implemented; we present example code and some preliminary performance measurements.</jats:p>},
  author = {Epstein, Jeff and Black, Andrew P. and Peyton-Jones, Simon},
  doi = {10.1145/2096148.2034690},
  issue = {12},
  journal = {ACM SIGPLAN Notices},
  language = {en},
  month = {1},
  pages = {118--129},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Towards Haskell in the cloud},
  url = {http://dx.doi.org/10.1145/2096148.2034690},
  volume = {46},
  year = {2012},
}

@inbook{TypeSystemsFoMcbrid2022,
  author = {McBride, Conor and Nordvall-Forsberg, Fredrik},
  doi = {10.1142/9789811242380\_0020},
  journal = {Series on Advances in Mathematics for Applied Sciences},
  month = {2},
  pages = {331--345},
  publisher = {WORLD SCIENTIFIC},
  title = {Type systems for programs respecting dimensions},
  url = {http://dx.doi.org/10.1142/9789811242380\_0020},
  year = {2022},
}

@article{Idris2QuantiBrady2021,
  abstract = {Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. As yet, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this paper, we introduce Idris 2, and describe how QTT has influenced its design. We give examples of the benefits of QTT in practice including: expressing which data is erased at run time, at the type level; and, resource tracking in the type system leading to type-safe concurrent programming with session types.},
  archiveprefix = {arXiv},
  author = {Brady, Edwin},
  eprint = {2104.00480v1},
  file = {2104.00480v1.pdf},
  month = {Apr},
  primaryclass = {cs.PL},
  title = {Idris 2: Quantitative Type Theory in Practice},
  url = {http://arxiv.org/abs/2104.00480v1},
  year = {2021},
}

@article{QuantitativePrOrchar2019,
  abstract = {<jats:p>In programming, some data acts as a resource (e.g., file handles, channels) subject to usage constraints. This poses a challenge to software correctness as most languages are agnostic to constraints on data. The approach of linear types provides a partial remedy, delineating data into resources to be used but never copied or discarded, and unconstrained values. Bounded Linear Logic provides a more fine-grained approach, quantifying non-linear use via an indexed-family of modalities. Recent work on coeffect types generalises this idea to graded comonads, providing type systems which can capture various program properties. Here, we propose the umbrella notion of graded modal types, encompassing coeffect types and dual notions of type-based effect reasoning via graded monads. In combination with linear and indexed types, we show that graded modal types provide an expressive type theory for quantitative program reasoning, advancing the reach of type systems to capture and verify a broader set of program properties. We demonstrate this approach via a type system embodied in a fully-fledged functional language called Granule, exploring various examples.</jats:p>},
  author = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
  doi = {10.1145/3341714},
  issue = {ICFP},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  month = {7},
  pages = {1--30},
  publisher = {Association for Computing Machinery (ACM)},
  title = {Quantitative program reasoning with graded modal types},
  url = {http://dx.doi.org/10.1145/3341714},
  volume = {3},
  year = {2019},
}

@inproceedings{HowToTakeTheMarsha2022,
  address = {Dagstuhl, Germany},
  annote = {Keywords: linear types, regular types, algebra of programming, derivatives},
  author = {Marshall, Daniel and Orchard, Dominic},
  booktitle = {36th European Conference on Object-Oriented Programming (ECOOP 2022)},
  doi = {10.4230/LIPIcs.ECOOP.2022.5},
  editor = {Ali, Karim and Vitek, Jan},
  isbn = {978-3-95977-225-9},
  issn = {1868-8969},
  pages = {5:1--5:27},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f\lbrace{}\textbackslash{}"u\rbrace{}r Informatik},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {How to Take the Inverse of a Type},
  url = {https://drops.dagstuhl.de/opus/volltexte/2022/16233},
  volume = {222},
  year = {2022},
}

@inproceedings{FutharkPurelyHenrik2017,
  author = {Henriksen, Troels and Serup, Niels G. W. and Elsman, Martin and Henglein, Fritz and Oancea, Cosmin E.},
  booktitle = {PLDI '17: ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/3062341.3062354},
  journal = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  month = {6},
  publisher = {ACM},
  title = {Futhark: purely functional GPU-programming with nested parallelism and in-place array updates},
  url = {http://dx.doi.org/10.1145/3062341.3062354},
  venue = {Barcelona Spain},
  year = {2017},
}

@article{ADataParallelAaron2019,
  author = {Aaron Hsu},
  title = {A data parallel compiler hosted on the GPU},
  year = {2019},
}

@inproceedings{UNetCnnInApHsuA2023,
  author = {Hsu, Aaron W. and Serr\~{a}o, Rodrigo Gir\~{a}o},
  booktitle = {ARRAY '23: 9th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  doi = {10.1145/3589246.3595371},
  journal = {Proceedings of the 9th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {U-Net CNN in APL: Exploring Zero-Framework, Zero-Library Machine Learning},
  url = {http://dx.doi.org/10.1145/3589246.3595371},
  venue = {Orlando FL USA},
  year = {2023},
}

@inproceedings{AplOnGpusAHenrik2016,
  author = {Henriksen, Troels and Dybdal, Martin and Urms, Henrik and Kiehn, Anna Sofie and Gavin, Daniel and Abelskov, Hjalte and Elsman, Martin and Oancea, Cosmin},
  booktitle = {ICFP'16: ACM SIGPLAN International Conference on Functional Programming},
  doi = {10.1145/2975991.2975997},
  journal = {Proceedings of the 5th International Workshop on Functional High-Performance Computing},
  month = {9},
  publisher = {ACM},
  title = {APL on GPUs: a TAIL from the past, scribbled in Futhark},
  url = {http://dx.doi.org/10.1145/2975991.2975997},
  venue = {Nara Japan},
  year = {2016},
}

@inproceedings{CompilationOnVoette2022,
  author = {Voetter, Robin F. and Huijben, Marcel and Rietveld, Kristian F. D.},
  booktitle = {CF '22: 19th ACM International Conference on Computing Frontiers},
  doi = {10.1145/3528416.3530249},
  journal = {Proceedings of the 19th ACM International Conference on Computing Frontiers},
  month = {5},
  publisher = {ACM},
  title = {Compilation on the GPU?},
  url = {http://dx.doi.org/10.1145/3528416.3530249},
  venue = {Turin Italy},
  year = {2022},
}

@inproceedings{CompilingAplTBudde2015,
  author = {Budde, Michael and Dybdal, Martin and Elsman, Martin},
  booktitle = {PLDI '15: ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/2774959.2774966},
  journal = {Proceedings of the 2nd ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {Compiling APL to accelerate through a typed array intermediate language},
  url = {http://dx.doi.org/10.1145/2774959.2774966},
  venue = {Portland OR USA},
  year = {2015},
}

@inproceedings{UnleashingGpusHaavis2022,
  author = {Haavisto, Juuso and Cholez, Thibault and Riekki, Jukka},
  booktitle = {NOMS 2022-2022 IEEE/IFIP Network Operations and Management Symposium},
  doi = {10.1109/noms54207.2022.9789822},
  journal = {NOMS 2022-2022 IEEE/IFIP Network Operations and Management Symposium},
  month = {4},
  publisher = {IEEE},
  title = {Unleashing GPUs for Network Function Virtualization: an open architecture based on Vulkan and Kubernetes},
  url = {http://dx.doi.org/10.1109/noms54207.2022.9789822},
  venue = {Budapest, Hungary},
  year = {2022},
}

@inproceedings{AcceleratingApGrelck1998,
  author = {Grelck, Clemens and Scholz, Sven-Bodo},
  booktitle = {APL99: 1999 Conference on APL},
  doi = {10.1145/312627.312719},
  journal = {Proceedings of the conference on APL \textbackslash{}textquotesingle 99 : On track to the 21st century: On track to the 21st century},
  month = {12},
  publisher = {ACM},
  title = {Accelerating APL programs with SAC},
  url = {http://dx.doi.org/10.1145/312627.312719},
  venue = {Scranton Pennsylvania USA},
  year = {1998},
}

@inproceedings{TeilATypeSaRink2019,
  author = {Rink, Norman A. and Castrillon, Jeronimo},
  booktitle = {PLDI '19: 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/3315454.3329959},
  journal = {Proceedings of the 6th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
  month = {6},
  publisher = {ACM},
  title = {TeIL: a type-safe imperative tensor intermediate language},
  url = {http://dx.doi.org/10.1145/3315454.3329959},
  venue = {Phoenix AZ USA},
  year = {2019},
}

@article{ApexTheAplPRobert1997,
  author = {Robert Bernecky},
  title = {APEX, the APL parallel executor},
  year = {1997},
}

@article{AplSince1978HuiR2020,
  abstract = {<jats:p>
            <jats:italic>The Evolution of APL</jats:italic>
            , the HOPL I paper by Falkoff and Iverson on APL, recounted the fundamental design principles which shaped the implementation of the APL language in 1966, and the early uses and other influences which shaped its first decade of enhancements.
          </jats:p>
          <jats:p>In the 40 years that have elapsed since HOPL I, several dozen APL implementations have come and gone. In the first decade or two, interpreters were typically born and buried along with the hardware or operating system that they were created for. More recently, the use of C as an implementation language provided APL interpreters with greater longevity and portability.</jats:p>
          <jats:p>
            APL started its life on IBM mainframes which were time-shared by multiple users. As the demand for computing resources grew and costs dropped, APL first moved
            <jats:italic>in-house</jats:italic>
            to mainframes, then to
            <jats:italic>mini</jats:italic>
            - and
            <jats:italic>micro</jats:italic>
            -computers. Today, APL runs on PCs and tablets, Apples and Raspberry Pis, smartphones and watches.
          </jats:p>
          <jats:p>The operating systems, and the software application platforms that APL runs on, have evolved beyond recognition. Tools like database systems have taken over many of the tasks that were initially implemented in APL or provided by the APL system, and new capabilities like parallel hardware have also changed the focus of design and implementation efforts through the years.</jats:p>
          <jats:p>The first wave of significant language enhancements occurred shortly after HOPL I, resulting in so-called second-generation APL systems. The most important feature of the second generation is the addition of general arrays\textemdash{}in which any item of an array can be another array\textemdash{}and a number of new functions and operators aligned with, if not always motivated by, the new data structures.</jats:p>
          <jats:p>The majority of implementations followed IBM's path with APL2 \textquotedblleft{}floating\textquotedblright{} arrays; others aligned themselves with SHARP APL and \textquotedblleft{}grounded\textquotedblright{} arrays. While the APL2 style of APL interpreters came to dominate the mainstream of the APL community, two new cousins of APL descended from the SHARP APL family tree: J (created by Iverson and Hui) and k (created by Arthur Whitney).</jats:p>
          <jats:p>We attempt to follow a reasonable number of threads through the last 40 years, to identify the most important factors that have shaped the evolution of APL. We will discuss the details of what we believe are the most significant language features that made it through the occasionally unnatural selection imposed by the loss of habitats that disappeared with hardware, software platforms, and business models.</jats:p>
          <jats:p>The history of APL now spans six decades. It is still the case, as Falkoff and Iverson remarked at the end of the HOPL I paper, that:</jats:p>
          <jats:p>Although this is not the place to discuss the future, it should be remarked that the evolution of APL is far from finished.</jats:p>},
  author = {Hui, Roger K. W. and Kromberg, Morten J.},
  doi = {10.1145/3386319},
  issue = {HOPL},
  journal = {Proceedings of the ACM on Programming Languages},
  language = {en},
  month = {6},
  pages = {1--108},
  publisher = {Association for Computing Machinery (ACM)},
  title = {APL since 1978},
  url = {http://dx.doi.org/10.1145/3386319},
  volume = {4},
  year = {2020},
}